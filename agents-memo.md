# Agent's Memo: Project-DJ-Engine Analysis

This document serves as a comprehensive internal memo to record all findings, analyses, and speculations about the Project-DJ-Engine repository. The goal is to build a foundational understanding of the project's architecture, conventions, and purpose.

## 1. High-Level Project Overview

*   **Project Name:** Project-DJ-Engine (PDJE)
*   **Core Purpose:** An integrated, production-ready C++20 engine combining rhythm game mechanics, DJ performance tools, and digital audio workstation (DAW) features into a single soft real-time system.
*   **Primary Value:** It enables the creation, reproduction, and remixing of DJ mixes, drives rhythm-game note charts, and facilitates interactive music experiences with low-latency, microsecond-level timing guarantees.
*   **Key Characteristics:**
    *   **Library-centric:** The engine is primarily a C++ library designed for integration into other applications, not a standalone executable.
    *   **Cross-Platform:** Supports Linux, macOS, and Windows.
    *   **Modular:** The architecture is divided into distinct modules (Core, Input, Judge, Utility).
    *   **No Built-in GUI:** The engine provides an API but does not include a graphical user interface.
*   **License:** LGPLv2.1 (inferred from `index.rst`, likely due to the SoundTouch dependency).

## 2. Directory Roles and Information

*   **`/` (Root):**
    *   **Role:** Contains top-level project configuration, build scripts, and metadata.
    *   **Key Files:** `CMakeLists.txt` (main build file), `conanfile.txt` (dependencies), `Doxyfile` (Doxygen config), `DOCUMENT_GENERATOR.sh` (doc build script), `PDJE_VERSION` (version file), `README.md`.
*   **`/.github/workflows/`:**
    *   **Role:** Contains CI/CD pipeline configurations using GitHub Actions.
    *   **Key Files:**
        *   `cmake-multi-platform.yml`: Defines the primary build and test workflow for Windows, Linux, and macOS. It uses `ctest` for testing.
        *   `autoTag.yml`: Automates Git tagging based on changes to the `PDJE_VERSION` file.
        *   `autotrigtest.yml`: Manually triggers a workflow in the external `PDJE_Godot_Plugin` repository.
*   **`/BluePrint_PDJE/`:**
    *   **Role:** Contains high-level design documents and conceptual notes in Markdown format. This seems to be the initial planning and brainstorming area for the project's features.
*   **`/cmakes/` & `/conan_cmakes/`:**
    *   **Role:** Build system support files. `/cmakes` holds custom CMake modules written for this project, while `/conan_cmakes` is generated by Conan to manage dependencies.
*   **`/DataExtract/`:**
    *   **Role:** A utility for performance analysis.
    *   **Contents:** Contains Python scripts (`csv_extract.py`, `visualize_csv.py`), data files (`.txt`, `.csv`), and generated plots (`.png`). This suggests it's used to process and visualize data related to the engine's performance under different rendering modes.
*   **`/document_sources/`:**
    *   **Role:** The source directory for the official Sphinx documentation.
    *   **Contents:** Contains `.rst` files, a `conf.py` for Sphinx configuration, and an `xml/` directory generated by Doxygen. This is the canonical source for the project's documentation website.
*   **`/docs/`:**
    *   **Role:** The output directory for the generated HTML documentation.
    *   **Contents:** This directory contains the static website built by Sphinx. It should not be edited directly.
*   **`/include/`:**
    *   **Role:** The primary location for *all* C++ source code, including both header (`.hpp`, `.h`) and implementation (`.cpp`, `.cxx`) files.

## 3. Module Roles and Information

The project is explicitly divided into several modules, both in the source code structure and the documentation.

*   **Core Engine (`include/core/`):**
    *   **Role:** The central and most critical component. It manages the database, audio processing, real-time mixing, and the editor.
    *   **Interface:** The public C++ API is defined in `include/core/interface/PDJE_interface.hpp`, centered around the `PDJE` class. This class acts as the main entry point to the engine's functionalities.
    *   **Audio Rendering (`audioRender/`):**
        *   The `audioRender` class is responsible for loading track data and mixing it into raw audio frames (`std::vector<float>`).
        *   It orchestrates `MixMachine`, `MixTranslator`, `CapReader` (for Cap'n Proto binary data), and `litedb`.
    *   **Database (`db/`):**
        *   **`litedb`:** The root database object, managing three types: SQLite (for `musicDB`/`trackDB` metadata), RocksDB (key-value store for raw audio files), and a conceptual vector database.
        *   **SQLite Interaction:** Uses `stmt` as a wrapper for `sqlite3_stmt` for safe data binding and column retrieval. `musdata` (music metadata) and `trackdata` (track metadata) define data models and methods (`GenSearchSTMT`, etc.) to generate SQL statements.
        *   **Cap'n Proto Integration:** Extensive use of Cap'n Proto for serializing critical data (`MixBinary`, `MusicBinary`, `NoteBinary` schemas). `CapReader` and `CapWriter` template classes provide generic wrappers for I/O.
        *   **Translators (`Capnp/Translators/`):**
            *   `FrameCalc`: Critical for time-based calculations, converting between musical beats/sub-beats and PCM audio frames. Defines `BpmFragment` and `BpmStruct` for managing BPM changes. Uses `clock_gettime` for high-resolution timing.
            *   `MixTranslator`: Reads `MixBinaryCapnpData` to populate application-specific `MIX` (mix events) and `BPM` (BPM change events) data structures. Uses multi-threading for performance.
            *   `MIX` class: Holds `MixStruct` objects, representing individual mix events with calculated `frame_in`/`frame_out` positions. `openMix()` sorts events chronologically; `WriteFrames()` calculates absolute frame positions in a multi-threaded manner.
            *   `BPM` class: Extracts BPM control events from `MIX` data, manages `BpmStruct` (sorting and calculating frame positions) in a multi-threaded fashion.
            *   `MusicTranslator`: Reads `MusicBinaryCapnpData` to populate a `BpmStruct` specifically for a music track, handling track-specific tempo changes.
            *   `NoteTranslator`: Reads `NoteBinaryCapnpData`, processes it with BPM information (including embedded BPM changes within note data), and calls a user-provided `OBJ_SETTER_CALLBACK` for each note.
    *   **Main Objects (`MainObjects/`):**
        *   **`audioPlayer`:** The high-level orchestrator for audio playback. Uses `miniaudio` for low-level audio. Supports pre-render, hybrid (pre-render + manual FX/music control), and full manual rendering modes. Exposes `FXControlPanel` and `MusicControlPanel` for real-time control. Provides `PDJE_CORE_DATA_LINE` for zero-copy access to audio state.
        *   **`audioEngineDataStruct`:** Holds all essential audio engine data, including PCM buffers (`faustPcmPP`), `FXControlPanel`, `MusicControlPanel`, `pcmDataPoint`, playback cursors, and `std::atomic<audioSyncData>` for thread-safe timing.
        *   **Audio Callbacks:** `FullPreRender_callback`, `HybridRender_callback`, `FullManualRender_callback` are `miniaudio` callbacks implementing the core audio loop logic for different rendering modes, emphasizing low-latency, high-resolution timing, and Faust integration for real-time effects.
        *   **`editorObject`:** The central class for managing project data in the editor.
            *   **Two-tiered Database:** Uses a `tempDB` (project-local `litedb`) as a sandbox for edits and `pushToRootDB` to commit changes to the global `litedb`. Raw audio files are stored in RocksDB.
            *   **Git-like Versioning:** Leverages `PDJE_Editor` as its core. `PDJE_Editor` manages multiple `PDJE_TIMELINE::TimeLine` instances (for mix, note, key-value, and music metadata), each acting as a Git repository tracking changes to JSON files. Features `AddLine`, `deleteLine`, `Undo`, `Redo`, `Go` (time travel), `GetLogWithJSONGraph`.
            *   **Data Models:** Uses `MixArgs`, `NoteArgs`, `MusicArgs`, `KEY_VALUE` as structured inputs for editing operations.
            *   **Data Sanitization:** Heavily relies on `PDJE_Name_Sanitizer` for safe handling of filenames and identifiers.
            *   **Linting (`pdjeLinter`):** `PDJE_Linter<trackdata>` checks for integrity of mix data, ensuring balanced `LOAD`/`UNLOAD` commands.
            *   **JSON Handling (`TimeLine/JSONWrap/`):** `PDJE_JSONHandler` template class acts as a bridge, serializing/deserializing structured C++ data to JSON for Git versioning, and then converting JSON to Cap'n Proto binaries for engine use. Specific `.cpp` files (`KVJson.cpp`, `MixJson.cpp`, `MusicJson.cpp`, `NoteJson.cpp`) implement this for each data type.
*   **Input Engine (`include/input/`):**
    *   **Role:** A cross-platform, low-latency input handling module.
    *   **Interface:** `PDJE_Input` is the main entry point, managing `DefaultDevs` (platform-specific input) and `PDJE_MIDI` (MIDI input). Provides `PDJE_INPUT_DATA_LINE` for zero-copy access to input events.
    *   **`DefaultDevs`:**
        *   **Linux:** Uses `libevdev` and `open` system calls directly.
        *   **Windows:** Spawns a child process that uses Windows Raw Input API, `CreateMessageWindow` (message-only window), and IPC (`Secured_IPC_TX_RX`) for communication. Prioritizes real-time performance with MMCSS and disabled power throttling.
    *   **Inter-Process Communication (IPC) (`IPC/`):**
        *   **`Secured_IPC_TX_RX`:** Implements secure IPC using shared memory (`SharedMem`), named mutexes (`MUTEX`), named events (`EVENT`), and `PDJE_CRYPTO::AEAD` for authenticated encryption. Defines a clear communication protocol (`TXRXHEADER`) for messages like `HEALTH_CHECK`, `DEVICE_CONFIG`, etc.
        *   **Shared Memory (`memory/`):** `SharedMem` is a platform-agnostic template using POSIX shared memory on Linux (`shm_open`, `mmap`) and Windows file mapping objects (`CreateFileMappingW`, `MapViewOfFile`). Supports `PDJE_NO_IPC` for non-IPC scenarios.
        *   **Named Events (`memory/`):** `EVENT` class uses POSIX semaphores on Linux (`sem_open`) and Windows event objects (`CreateEventW`) for inter-process synchronization.
        *   **Named Mutexes (`memory/`):** `MUTEX` class uses POSIX semaphores on Linux and Windows mutex objects (`CreateMutexW`) for inter-process mutual exclusion.
        *   **Utilities (`common/`):**
            *   `ipc_util`: Verifies integrity of child process executable using SHA256 hashing (`EMBEDDED_INPUT_PROCESS_SHA256`).
            *   `NameGen`: Generates cryptographically secure random names for IPC resources using Botan.
        *   **`PSKPipe`:** Specifically used for Windows IPC to securely pass tokens (like the `PSK`) to child processes via standard I/O pipes.
        *   **`PDJE_Input_Transfer`:** A specialized container for securely transferring input log data via shared memory. On Linux, it uses `Atomic_Double_Buffer`; on Windows, it uses a more complex setup with multiple shared memory segments, events, and HMAC.
    *   **MIDI (`midi/`):**
        *   `PDJE_MIDI` class integrates with `libremidi` for MIDI device discovery, configuration, and event processing.
        *   `MIDI_EV` struct defines MIDI event data, timestamped with `PDJE_HIGHRES_CLOCK`.
        *   Uses `Atomic_Double_Buffer<MIDI_EV>` for efficient, low-latency MIDI event delivery. Handles advanced CC messages.
    *   **Subprocess Runner (`runner/`):**
        *   `TXRXListener` (in child process) handles IPC commands, configures devices, and sends input data back to the main process.
*   **Judge Engine (`include/judge/`):**
    *   **Role:** Handles rhythm-game timing logic and real-time judgments with microsecond accuracy.
    *   **Interface:** `PDJE_JUDGE::JUDGE` is the main controller, managing the judgment lifecycle in a separate thread.
    *   **`PDJE_Rule.hpp`:** Defines `EVENT_RULE` (miss/use timing windows) and `RAIL_KEY` structs (`KB_MOUSE`, `MIDI`, `META`) for mapping input events to game rails.
    *   **`PDJE_RAIL.hpp`:** `RAIL_DB` manages input-to-rail mappings, using custom `std::hash` specializations for efficient lookups.
    *   **Initialization (`Init/`):**
        *   `Judge_Init` holds all configuration: `PDJE_CORE_DATA_LINE`, `PDJE_INPUT_DATA_LINE`, `OBJ` (note objects), `EVENT_RULE`, `RAIL_DB`, and `Custom_Events` (callbacks).
        *   `NoteObjectCollector` processes parsed notes into `OBJ`.
        *   `PDJE_Judge_Init_Structs.hpp` defines `Custom_Events` (callbacks for miss/use, mouse parsing) and `Convert_Frame_Into_MicroSecond`.
    *   **Input Parsing (`InputParser/`):** Static `Parse` functions process raw input (`PDJE_Input_Log`, `PDJE_MIDI::MIDI_EV`), applying offsets from `RAIL_DB` and sorting chronologically.
    *   **Loop (`Loop/`):**
        *   `Judge_Loop` orchestrates the judgment loop: `PreProcess` fetches/parses input, `Match` compares with notes.
        *   Asynchronous `use_event_thread` and `miss_event_thread` (managed by `EV_Thread` and `Queues` with `Atomic_Double_Buffer`s) handle callbacks without blocking the main loop.
        *   `PDJE_Judge_Loop_Structs.hpp` defines `EV_Thread`, `useDatas`, and `Queues`.
    *   **Matching (`Loop/Match/`):**
        *   `Match` class compares processed input events with active note objects.
        *   `Work()`: Core note matching logic, checks hit windows, pushes results to `use_queue`. Includes a `todo` to find the closest note.
        *   `UseEvent()` (specialized for `KEYBOARD`, `MOUSE`, `MIDI`): Entry points for specific input types, maps events to rails, retrieves notes from `OBJ`'s buffers (`BUFFER_MAIN`/`BUFFER_SUB`).
        *   Mouse handling: Detailed `ParseMouse` for button states and wheel movements. Custom mouse parse callback for axis movement.
        *   MIDI handling: Skips `CONTROL_CHANGE` and `PITCH_BEND` until `AxisModel` is implemented.
    *   **Note Objects (`NoteOBJ/`):**
        *   `OBJ` class manages `NOTE` objects in `Buffer_Main` and `Buffer_Sub` (for active/release notes).
        *   `NOTE` struct is the fundamental judagble unit.
        *   `Sort()`: Sorts notes chronologically.
        *   `Fill()`: Adds notes.
        *   `Get()`: Retrieves notes within a time limit.
        *   `Cut()`: Identifies and queues "missed" (expired) notes.
    *   **`AxisModel` (`AxisModel/`):** Currently an empty placeholder class, intended for future implementation of axis-based input.
*   **Utility Engine (`include/???` - mentioned in docs, path not explicit):**
    *   **Status:** Confirmed placeholder/future feature.
*   **Data Lines (`include/global/DataLines/`):**
    *   **`PDJE_Core_DataLine.hpp`:** `PDJE_CORE_DATA_LINE` struct for zero-copy access to audio engine state (playback cursors, pre-rendered data, `audioSyncData`).
    *   **`PDJE_Input_DataLine.hpp`:** `PDJE_INPUT_DATA_LINE` struct for zero-copy access to input events (`PDJE_IPC::PDJE_Input_Transfer` shared memory, `Atomic_Double_Buffer` for MIDI).
    *   **`PDJE_Input_Device_Data.hpp`:** `DeviceData` struct and `PDJE_Dev_Type` enum for describing input devices.
    *   **`PDJE_Buffer.hpp`:** `Atomic_Double_Buffer` template class for thread-safe, high-performance data exchange.
    *   **`fileNameSanitizer.hpp`/`.cpp`:** `PDJE_Name_Sanitizer` uses URL-safe Base64 for filenames, with length checks.
*   **FX Arguments (`document_sources/FX_ARGS.rst`):**
    *   **Role:** A reference guide for the arguments of each available audio effect (FX).

## 4. Documentation Build System

The project uses a combination of Doxygen and Sphinx to generate its documentation.

*   **Doxygen:** Used to extract documentation from the C++ source code comments into an XML format. The configuration is in `Doxyfile`, and the output is stored in `document_sources/xml/`.
*   **Sphinx:** A documentation generator that takes `.rst` files and the Doxygen XML output to build the final HTML documentation website.
    *   **`conf.py`:** The main configuration file for Sphinx. Uses `breathe`, `exhale`, `sphinx.ext.graphviz`, `sphinx_design`, `sphinxcontrib.mermaid` extensions.
*   **Build Process:** The `DOCUMENT_GENERATOR.sh` script automates the process:
    1.  `doxygen ./Doxyfile`
    2.  `sphinx-build -b html ./document_sources docs`

## 5. Implementation and Declaration File Placement

*   **Observation:** The most unconventional aspect of this project is that all C++ source code—both headers (`.hpp`) and implementation files (`.cpp`)—resides within the `/include/` directory.
*   **Refined Speculation on Intent:**
    1.  **Simplicity of Build Configuration:** Confirmed. This structure simplifies `CMakeLists.txt` and Conan package management.
    2.  **Facilitate Library Usage:** By having all source in `include/`, it might make it easier for other projects to consume the PDJE as a header-only or pre-compiled library by just including the top-level directory.
    3.  **Module Collocation:** Confirmed. Co-locating `.hpp` and `.cpp` files within their respective module directories (e.g., `include/core/db/`) keeps related code together, which can aid developer navigation.

## 6. Global Utilities

*   **`PDJE_EXPORT_SETTER.hpp`:** Defines `PDJE_API` macro for cross-platform DLL import/export management.
*   **`PDJE_LOG_SETTER.hpp`:** Configures `spdlog` for file logging (debug/err levels, custom pattern) and defines logging macros (`infolog`, `warnlog`, `critlog`).
*   **`PDJE_ATOMIC_EVENT.hpp`:** Defines `ATOMIC_EVENT` for inter-thread signaling using C++20 atomic `wait()`/`notify_one()`.
*   **`PDJE_Benchmark.hpp`:** Provides a conditional benchmarking utility (`WBCH()` macro) using `PDJE_HIGHRES_CLOCK` to measure microsecond-accurate timings, writing results to `benchRes.txt`.
*   **`PDJE_OBJ_SETTER.hpp`:** Defines `OBJ_SETTER_CALLBACK` as a `std::function` for passing parsed note data to the application layer.
*   **`PDJE_RAII_WRAP.hpp`:** Defines a generic `RAII` template class for safe resource management using a custom `Deleter`.
*   **`PDJE_SYNC_CORE.hpp`:** Defines `audioSyncData` struct for thread-safe synchronization of audio playback (consumed frames, microsecond timestamp).
*   **High-Resolution Clock (`Highres_Clock/`):** Platform-specific implementations for microsecond-accurate monotonic clocks (Linux: `clock_gettime(CLOCK_MONOTONIC)`, macOS: `clock_gettime(CLOCK_MONOTONIC_RAW)`, Windows: `QueryPerformanceCounter`).
*   **Cryptography (`Crypto/`):**
    *   Leverages the `Botan` library.
    *   `PDJE_Crypto.hpp`: Defines `Hash` (SHA256 file/text hashing), `PSK` (pre-shared key generation/encoding), and `AEAD` (authenticated encryption/decryption with AES-256/GCM).
    *   `PSKPipe.hpp`: IPC mechanism for secure token passing (e.g., PSK) to child processes, primarily implemented on Windows using standard I/O pipes.

## 7. Discrepancies Found

*   **Input Engine Platform Support:** `Input_Engine.rst` warning "Currently only Windows implementation is supported" is outdated. The source code (`include/input/DefaultDevs/linux/` and `include/input/DefaultDevs/windows/`) shows active, platform-specific implementations for both Linux and Windows.
*   **Utility Engine Status:** `Util_Engine.rst` indicates the module is "Available on PDJE 1.2.0", implying it's a future feature. This contradicts `index.rst` which describes it as an existing module. This is confirmed as a placeholder module in code.
*   **SWIG Content in Documentation:** Code blocks for C#, Python, GDScript were present in `Core_Engine.rst`, `Input_Engine.rst`, `Judge_Engine.rst`, and `Data_Lines.rst`. These have been removed from `.rst` files as per user instruction.
*   **API Divergence in Bindings:** The GDScript example in `Data_Lines.rst` showed `core_line.GetPreRenderedFrames()` while C++ used direct member access `core_line.preRenderedData`. This discrepancy has been removed from documentation with SWIG content removal.
*   **`AXIS_MODEL` Implementation:** The `AXIS_MODEL` class (`include/judge/AxisModel/AxisModel.hpp`) is currently empty, serving as a placeholder for a planned feature, which affects how continuous MIDI events (`CONTROL_CHANGE`, `PITCH_BEND`) and mouse axis movements are handled in judging.
*   **`Match::Work()` Algorithm:** The `Work()` method in `include/judge/Loop/Match/PDJE_Match.cpp` contains a `todo` comment: `//todo - edit algorithm (make it finds the closest note. not the first one.)`, indicating a known area for improvement in the note matching logic.
*   **`TimeLine::Diff()` Method:** The `Diff()` method in `include/core/editor/TimeLine/TimeLine.hpp` is commented out as `// DEPRECATE DIFF For Now`, indicating that this feature is currently not implemented or is under review.
